/*****************************************************************************
* University of Southern Denmark
* Embedded Programming (EMP)
*
* MODULENAME.: lcd.c
*
* PROJECT....: EMP
*
* DESCRIPTION: See module specification file (.h-file).
*
* Change Log:
******************************************************************************
* Date    Id    Change
* YYMMDD
* --------------------
* 090222  MoH   Module created.
*
*****************************************************************************/

/***************************** Include files *******************************/
#include <stdint.h>
#include <tm4c123gh6pm.h>
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "semphr.h"

#include "PID/pid.h"
#include "EMP/emp_type.h"
#include "Tasking/tmodel.h"
#include "Tasking/messages.h"

/*****************************    Defines    *******************************/

#define DT 		4		// 5ms * 1000
#define O_MAX	40
#define O_MIN	-40
#define I_MAX	1000
#define I_MIN	-1000
#define DC_MAX	150
#define DC_MIN	60
#define KP		33
#define KI		0
#define KD		20
#define TILT_MIN 	5
#define TILT_MAX 	10
#define THETA_1 	5
#define THETA_3 	355
#define TILT_OFFSET 0
#define INDEX_TILT 	5
#define INDEX_PAN 	5
#define PAN_DIRECTION_OFFSET 90

#define SSM_SP_PAN_TICKS		56
#define SSM_SP_TILT_TICKS		57

/*****************************   Constants   *******************************/

/*****************************   Variables   *******************************/

PID pan_sys;
PID tilt_sys;

extern xQueueHandle SPI_queue;
extern xQueueHandle PID_queue;
extern xSemaphoreHandle coordinate_access_sem;

/*****************************   Functions   *******************************/

void convert_and_secure_pan(void)
{


	if(xSemaphoreTake(coordinate_access_sem, 100))
	{
		INT32U pan = get_msg_state(SSM_SP_PAN);
		INT32U tilt =get_msg_state(SSM_SP_TILT);

		if (tilt > TILT_MIN && tilt < TILT_MAX)
		{
			tilt = INDEX_TILT;
			pan = INDEX_PAN;
			xSemaphoreGive(coordinate_access_sem);
			return;
		}

		if(pan > 180)
		{
			if(pan > THETA_3)
			{
				tilt = INDEX_TILT;
				pan = INDEX_PAN;
				xSemaphoreGive(coordinate_access_sem);
				return;
			}

			pan = pan-180;
			if(tilt < 90)
			{
				tilt = tilt - 2*(tilt-90);
			}
			else if(tilt > 90)
			{
				tilt = tilt + 2*(90-tilt);
			}

		}
		else if(pan > THETA_1)
		{
			tilt = INDEX_TILT;
			pan = INDEX_PAN;
			xSemaphoreGive(coordinate_access_sem);
			return;
		}
		xSemaphoreGive(coordinate_access_sem);
		tilt = 3 * tilt + INDEX_TILT;
		pan = 3 * pan + INDEX_PAN + PAN_DIRECTION_OFFSET;

	}
}

void init_pid()
{
	pan_sys.Kp = KP;
	pan_sys.Ki = KI;
	pan_sys.Kd = KD;
	pan_sys.integral = 0;
	pan_sys.prev_error = 0;

	tilt_sys.Kp = KP;
	tilt_sys.Ki = KI;
	tilt_sys.Kd = KD;
	tilt_sys.integral = 0;
	tilt_sys.prev_error = 0;
}

void PID_task(void *pvParameters)
{
	init_pid();

	INT8U received;

	while(1)
	{

		if (xQueueReceive(PID_queue, &received, 20500 / portTICK_RATE_MS))
		{
			switch(received)
			{
			case PID_UPDATE_EVENT:
				pid_update();
				break;

			default:
				break;
			}
		}
	}
}

INT32S pid_calc(INT32U desired, INT32U actual, PID *controller)
{
	INT32S error;
	INT32S derivative;
	INT32S integral;
	INT32S output;
	
	error = desired - actual;
	integral = controller->integral;
	integral = integral + error*DT;
	
	if(integral > I_MAX)
		integral = I_MAX;
	if(integral < I_MIN)
		integral = I_MIN;
		
	derivative = (error - controller->prev_error)/DT;

	output = controller->Kp*error + controller->Ki*integral + controller->Kd*derivative;

	output /= 1000;

	if(output > O_MAX)
		output = O_MAX;
	if(output < O_MIN)
		output = O_MIN;

	controller->integral = integral;
	controller->prev_error = error;

	return output;
}

void pid_update()
{
	INT32S set_point;
	INT32S actual;
	INT32S adjust;
	INT8U dir;
	INT16U duty_cycle;

	convert_and_secure_pan();

	set_point 	= get_msg_state(SSM_SP_PAN_TICKS);
	actual 		= get_msg_state(SSM_POS_PAN);

	adjust = pid_calc(set_point,actual,&pan_sys);

	////
	dir = 0;
	////

	if(set_point != actual)
	{
		if(adjust < 0)
			dir = 1;
		else
			dir = 2;
	}

	duty_cycle = pwm_conv(adjust);

	duty_cycle = (dir<<8) | duty_cycle;		// direction is ored to the 9-10th bit
	//if(set_point != actual)
		duty_cycle = 0x0400 | duty_cycle;

	put_msg_state(SSM_PWM_DIR_EN_PAN,duty_cycle);

	// send duty cycle og direction til SPI
	dir = 0;
	// hent ny v�rdi fra feedback for TILT
	// udregn PWM v�rdi fra pid_calc() og send til SPI modul

	set_point 	= get_msg_state(SSM_SP_TILT_TICKS);
	actual	  	= get_msg_state(SSM_POS_TILT);
	adjust = pid_calc(set_point,actual,&tilt_sys);
	if(set_point != actual)
	{
		if(adjust < 0)
			dir = 1;
		else
			dir = 2;
	}


	duty_cycle = pwm_conv(adjust);

	duty_cycle = (dir<<8) | duty_cycle;
	//if(set_point != actual)
		duty_cycle = 0x0400 | duty_cycle;

	put_msg_state(SSM_PWM_DIR_EN_TILT,duty_cycle);

	// send duty cycle og direction til SPI
	INT8U event;
	event = SET_PWM_EVENT;
	xQueueSend(SPI_queue,&event,500 / portTICK_RATE_MS);

		vTaskDelay(4 / portTICK_RATE_MS);

	event = GET_POS_EVENT;
	xQueueSend(SPI_queue,&event,500 / portTICK_RATE_MS);
}

INT16U pwm_conv(INT32S output)
{
	if(output < 0)
		output *= -1;

	INT32U ratio = (output*1000) / O_MAX ;

	INT32U result = 255 * ratio;
	result /= 1000;

	if(result > DC_MAX)
		result = DC_MAX;
	if(result < DC_MIN)
		result = DC_MIN;

	return result;

}


/****************************** End Of Module *******************************/
